var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// src/index.ts
__export(exports, {
  getIronSession: () => getIronSession,
  sealData: () => sealData,
  unsealData: () => unsealData
});
var import_iron = __toModule(require("@hapi/iron"));
var import_cookie = __toModule(require("cookie"));
var timestampSkewSec = 60;
var fourteenDaysInSeconds = 15 * 24 * 3600;
var currentMajorVersion = 2;
var versionDelimiter = "~";
var defaultOptions = {
  ttl: fourteenDaysInSeconds,
  cookieOptions: {
    httpOnly: true,
    secure: true,
    sameSite: "lax",
    path: "/"
  }
};
async function getIronSession(req, res, userSessionOptions) {
  if (!req || !res || !userSessionOptions || !userSessionOptions.cookieName || !userSessionOptions.password) {
    throw new Error(`iron-session: Bad usage. Minimum usage is const session = await getIronSession(req, res, { cookieName: "...", password: "...". Check the usage here: https://github.com/vvo/iron-session`);
  }
  const passwordsAsMap = normalizeStringPasswordToMap(userSessionOptions.password);
  Object.values(normalizeStringPasswordToMap(userSessionOptions.password)).forEach((password) => {
    if (password.length < 32) {
      throw new Error(`iron-session: Bad usage. Password must be at least 32 characters long.`);
    }
  });
  const options = {
    ...defaultOptions,
    ...userSessionOptions,
    cookieOptions: {
      ...defaultOptions.cookieOptions,
      ...userSessionOptions.cookieOptions || {}
    }
  };
  if (options.ttl === 0) {
    options.ttl = 2147483647;
  }
  if (userSessionOptions.cookieOptions && "maxAge" in userSessionOptions.cookieOptions) {
    if (userSessionOptions.cookieOptions.maxAge === void 0) {
      options.ttl = 0;
    } else {
      options.cookieOptions.maxAge = computeCookieMaxAge(userSessionOptions.cookieOptions.maxAge);
    }
  } else {
    options.cookieOptions.maxAge = computeCookieMaxAge(options.ttl);
  }
  const sealFromCookies = import_cookie.default.parse(req.headers.cookie || "")[options.cookieName];
  const session = sealFromCookies === void 0 ? {} : await unsealData(sealFromCookies, {
    password: passwordsAsMap,
    ttl: options.ttl
  });
  Object.defineProperties(session, {
    save: {
      value: async function save() {
        if (res.headersSent === true) {
          throw new Error(`iron-session: Cannot set session cookie: session.save() was called after headers were sent. Make sure to call it before any res.send() or res.end()`);
        }
        const seal = await sealData(session, {
          password: passwordsAsMap,
          ttl: options.ttl
        });
        const cookieValue = import_cookie.default.serialize(options.cookieName, seal, options.cookieOptions);
        if (cookieValue.length > 4096) {
          throw new Error(`iron-session: Cookie length is too big ${cookieValue.length}, browsers will refuse it. Try to remove some data.`);
        }
        addToCookies(cookieValue, res);
      }
    },
    destroy: {
      value: function destroy() {
        Object.keys(session).forEach((key) => {
          delete session[key];
        });
        const cookieValue = import_cookie.default.serialize(options.cookieName, "", {
          ...options.cookieOptions,
          maxAge: 0
        });
        addToCookies(cookieValue, res);
      }
    }
  });
  return session;
}
function addToCookies(cookieValue, res) {
  var _a;
  let existingSetCookie = (_a = res.getHeader("set-cookie")) != null ? _a : [];
  if (typeof existingSetCookie === "string") {
    existingSetCookie = [existingSetCookie];
  }
  res.setHeader("set-cookie", [...existingSetCookie, cookieValue]);
}
function computeCookieMaxAge(ttl) {
  return ttl - timestampSkewSec;
}
async function unsealData(seal, {
  password,
  ttl = fourteenDaysInSeconds
}) {
  const passwordsAsMap = normalizeStringPasswordToMap(password);
  const { sealWithoutVersion, tokenVersion } = parseSeal(seal);
  try {
    const data = await import_iron.default.unseal(sealWithoutVersion, passwordsAsMap, {
      ...import_iron.default.defaults,
      ttl: ttl * 1e3
    });
    if (tokenVersion === 2) {
      return data;
    }
    return {
      ...data.persistent
    };
  } catch (error) {
    if (error instanceof Error) {
      if (error.message === "Expired seal" || error.message === "Bad hmac value" || error.message === "Cannot find password: " || error.message === "Incorrect number of sealed components") {
        return {};
      }
    }
    throw error;
  }
}
function parseSeal(seal) {
  if (seal[seal.length - 2] === versionDelimiter) {
    const [sealWithoutVersion, tokenVersionAsString] = seal.split(versionDelimiter);
    return {
      sealWithoutVersion,
      tokenVersion: parseInt(tokenVersionAsString, 10)
    };
  }
  return { sealWithoutVersion: seal, tokenVersion: null };
}
async function sealData(data, {
  password,
  ttl = fourteenDaysInSeconds
}) {
  const passwordsAsMap = normalizeStringPasswordToMap(password);
  const mostRecentPasswordId = Math.max(...Object.keys(passwordsAsMap).map((id) => parseInt(id, 10)));
  const passwordForSeal = {
    id: mostRecentPasswordId.toString(),
    secret: passwordsAsMap[mostRecentPasswordId]
  };
  const seal = await import_iron.default.seal(data, passwordForSeal, {
    ...import_iron.default.defaults,
    ttl: ttl * 1e3
  });
  return `${seal}${versionDelimiter}${currentMajorVersion}`;
}
function normalizeStringPasswordToMap(password) {
  return typeof password === "string" ? { 1: password } : password;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getIronSession,
  sealData,
  unsealData
});
//# sourceMappingURL=index.js.map
